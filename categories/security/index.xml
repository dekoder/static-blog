<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security on n0b0dy&#39;s site</title>
    <link>https://n0b0dycn.me/categories/security/</link>
    <description>Recent content in Security on n0b0dy&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Jul 2019 10:08:33 +0800</lastBuildDate>
    
	<atom:link href="https://n0b0dycn.me/categories/security/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redis &lt;= 5.0.5 RCE</title>
      <link>https://n0b0dycn.me/2019/07/redis-rce/</link>
      <pubDate>Sun, 07 Jul 2019 10:08:33 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/07/redis-rce/</guid>
      <description>Redis &amp;lt;= 5.0.5 RCE 本文介绍由LCBC战队队员Pavel Toporkov在zeronights 2018上介绍的redis 4.x RCE攻击。会议slide链接：https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf
攻击场景： * 能够访问远程redis的端口（直接访问或者SSRF） * 对redis服务器可以访问到的另一台服务器有控制权
本文的exp开源在github上：
https://github.com/n0b0dyCN/redis-rogue-server
欢迎大家来star~
背景知识 redis协议 redis支持两种传输协议，一种是明文传输，其命令如下：
SET keyname value\n  另一种是经过编码的传输协议：
*3\r\n$3\r\nSET\r\n$7\r\nkeyname\r\n$5\r\nval ue\r\n  将其格式化大概长这个样子：
*&amp;lt;number of arguments&amp;gt; CR LF $&amp;lt;number of bytes of argument 1&amp;gt; CR LF &amp;lt;argument data&amp;gt; CR LF ... $&amp;lt;number of bytes of argument N&amp;gt; CR LF &amp;lt;argument data&amp;gt; CR LF  笔者主要使用第二种协议实现exp。
CONFIG SET CONFIG SET命令用于对redis进行配置。常用如下：
CONFIG SET dir /VAR/WWW/HTML CONFIG SET dbfilename sh.</description>
    </item>
    
    <item>
      <title>0ctf 2019 Quals Web writeup</title>
      <link>https://n0b0dycn.me/2019/03/0ctf-2019-quals-web-writeup/</link>
      <pubDate>Tue, 26 Mar 2019 16:04:55 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/03/0ctf-2019-quals-web-writeup/</guid>
      <description>本次比赛两个web题都是RicterZ大佬出的，膜一波Orz
Ghost Pepper 本题首先通过观察401的响应包找到HTTP Basic认证的用户名karaf：
然后用密码karaf即可绕过认证。接下来通过目录爆破找到目录http://karaf:karaf@192.168.2.88:31337/jolokia/。到这里我们可以发现这是一个裸的jolokia控制台。
jolokia是一个Java系统管理解决方案。其采用轻量级的Json格式传输数据，可以方便地管理系统中的Servlet。所以当应用暴露了jolokia目录的时候，基本上算是直接暴露出来一个webshell。我们可以通过访问http://karaf:karaf@192.168.2.88:31337/jolokia/list来查看可用的api，来寻找利用点。在本题中有三种解题方式：
解法 1 通过karaf下bundle模块远程安装一个我们自己写的恶意bundle，反弹一个shell到自己的服务器上。参考https://github.com/p4-team/ctf/tree/master/2019-03-23-0ctf-quals/web_osgi。但是由于我不熟悉Java编译出来的东西始终装不上Orz，等弄好了把整个项目代码扔github上面去= =
解法 2 第二种方法应该算是最省事的方法了，即通过karaf下feature模块安装一个webconsole：
之后我们访问http://192.168.2.88:31337/system/console/bundles就可以进入到webconsole的管理界面。在管理界面点Main -&amp;gt; Goto即可进入console。
在console中执行cat /flag即可得到flag：
解法 3 使用karaf中的Instance模块，在安装一个新的instance的时候进行instance的命令行参数注入。我们看karaf源码：https://github.com/apache/karaf。在org/apache/karaf/instance/core/InstancesMBean.java文件中定义了MBean的接口：
// Operations void startInstance(String name) throws MBeanException; void startInstance(String name, String opts) throws MBeanException; void startInstance(String name, String opts, boolean wait, boolean debug) throws MBeanException;  我们找startInstance方法的实现，在文件org/apache/karaf/instance/command/StartCommand.java中其调用了Instance的Start方法：
跟进Instance类的start方法，其调用了InstanceService中的startInstance方法：
继续跟进org/apache/karaf/instance/core/internal/InstanceServiceImpl.java，其调用了doStart方法：
继续看doStart方法，其中有明显的命令拼接：
在此处，我们发现javaOpt是我们可控的参数。在InstancesMBeanImpl中我们发现createInstance参数有一个就是javaOpt：
于是我们给出攻击思路：
 创建一个新的Instance，在其javaOpt字段进行参数注入 开启这个新的Instance执行我们的命令 停止Instance 删除Instance  最后我们给出exp：
import requests from pprint import pprint url = &amp;quot;http://111.</description>
    </item>
    
  </channel>
</rss>