<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on n0b0dy&#39;s site</title>
    <link>https://n0b0dycn.me/posts/</link>
    <description>Recent content in Posts on n0b0dy&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2019 11:34:22 +0800</lastBuildDate>
    
	<atom:link href="https://n0b0dycn.me/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Defcon 27游记</title>
      <link>https://n0b0dycn.me/2019/08/defcon27/</link>
      <pubDate>Sat, 10 Aug 2019 11:34:22 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/08/defcon27/</guid>
      <description>飞机上无事，记录一下第一次打defcon的参赛经历以及在华盛顿D.C.的游记。
签证 在6.9的0ctf获得冠军以后，我就开始准备签证。经过了一番纠结和调研以后，决定在6月24号和国佬一起去沈阳的使馆签证。我在23号的晚上抵达沈阳，吃了个烤串以后就回到酒店休息了。我订的酒店离使馆步行只有不到十分钟的旅程，很大程度上节省了跑来跑去的时间。24号面签，在签证官要了我导师的简历以后果断被check，而国佬则顺利拿到了十年签。
由于这次面签比去年早，所以我最开始觉得还是比较稳的。但是直到8月签证还没有issue，就感觉又要凉凉。最后8月2号签证issue，8月6号在中信自取到护照。由于队友们6号凌晨就走了，所以在6号当天买了7号的飞机，和TD的大佬们搭伙飞往Las Vegas。
DEFCON 8月7日 中午11点左右抵达Las Vegas，住在Planet Hollywood酒店。从机场打车大概十几刀就可以到，路程大概十几分钟。到酒店后直接把行李扔前台然后去和队友们到唐人街吃麻辣烫。丁佬的同学的男票开车贼猛，特别害怕.jpg。麻辣烫特别辣，如果有同学去吃除非四川重庆硬汉否则千万不要点特辣的。
下午在房间休息了一下之后晚上去参加了百度的晚宴，于是第一次走进了大名鼎鼎的巴黎酒店。虽然后几天看惯了这些酒店以后感觉见怪不怪，但是第一次看赌场酒店的装潢还是很开眼的。晚宴是西餐，队友们都觉得贼难吃但是我觉得还不错。回到房间以后就直接洗洗睡了。
8月8日 由于本身比赛也是昏天暗地的打，于是就没有特地倒时差。所以defcon期间我基本上都是凌晨3点左右就醒了。早上起来和atum，夜影，Neo，pupi1es吃了个自助早饭。这顿早饭是我在美国吃到的最丰盛的一顿早饭，也让队友对我的食量有了一个明确的认知。吃完饭回房间准备defcon主办方说明需要准备的环境。中午在Caesars Palace吃自助，麦香的老板请客。实际上自助还是不错的，但是由于早饭吃的太多所以其实这顿并没有吃很多。晚上由于时差直接睡过晚饭，晚上9点多起床继续装环境，12点睡3点醒。
8月9日 DEFCON第一天。6点起床和Harold一起吃了麦当劳的早饭，吃完以后帮Oroggs带了一份回房间。9点到比赛现场10点开始比赛。在分工里我被分配到了代码组，但实际上我在比赛中的主要任务就是写写bot，遇到和web沾边儿的题帮忙提供一点思路，以及后勤。第一天twitter的bot上线以后以及本来想写一个统计分数的bot，结果怎么算都和主办方给出的分数不一样，遂放弃，后知主办方的计分似乎出了点儿bug。
第一天开场放了两道题目，分别为telooogram与ropship。前者是一个ios的AWD，我们队成功拿下了一波分，但是似乎由于非预期解过多被早早下线。ropship是一个KoH的题目，通过rop操作小船互相打子弹。由于我队任务分配原因，这道题到最后也没有实现最基本的功能，即让小船动起来，导致一直没有得分。此题在当天比赛结束前被关闭。
下午另一个AWD题目aoool上线。这道题是一个手搓的类似nginx的反向代理服务器。这是一个c++的lexer，我们没有能够很完整地把这个题逆完，也没有成功猜出配置文件格式，导致我们压根没有把这个服务成功跑起来。期间发现了部分crash但是没有能够成功利用。在流量放出来以后我们写了脚本收了一波分。
这天还有一个题是AI-HAN-SOLO。这个题和去年的那个深度学习的题有点类似。由于没做这道题所以并不是很了解具体情况，似乎最后也没太搞出来。
晚上结束的时候剩了aoool和AI-HAN-SOLO，大家各自做题。晚饭是外卖的panda express。在三顿吃到一样的菜以后这辈子都不太想吃这个了QAQ。
8月10日 照例3点多睡醒，早上在房间吃到了麦当劳的早饭，此处感谢蓝猫和pupi1es送温暖。9点左右到达赛场后放了xbox题目booom，然后我们就发现我们没得显示器。试了一下Neo的发展需要驱动用不了，于是我和麦香去附近的best buy直接买了一个。但是显示器买回来以后疑似xbox坏了，导致这道题又没怎么搞，十分蛋疼。最后发现xbox其实没坏，于是就觉得更蛋疼了。
接着主办方放出了两个题，babi和mirror-universe。babi是一个rust搓的php，有反序列化的操作。似乎有double free漏洞但是没能利用成功。mirror-universe是一个lisp的题目，没看所以不太清楚什么情况，但是好像全场被PPP爆捶。
之后又放了一个KoH题目bitflip-conjecture。这个题目目的是写shellcode输出一个字符串，在随机flip一个bit后代码仍然能够正常工作。晚上我们把这道题搞到了996分。
午饭和晚饭吃的都是panda express。晚上临结束的时候放出了super smash ooos。
8月11日 11号是比赛的最后一天。由于我们的房间11号中午11点就要退房，于是早上把行李搬到了套房。这天scoreboard和game status都不再更新。其实昨天写了一个统计每轮播报game status的bot，但是出了一个很傻逼的bug导致一直没有work，惨兮兮。10点左右放了一个web题，我们迅速把显而易见的洞补了，但是到最后也没成功写出exp。 在11点左右，TD将bitflip做到了1000分，十分牛逼。之后问Riatre得知他们是手搓到999以后用机器枚举出来的。
下午2点比赛结束，大家在场地social一下喝一点酒，到4点多去楼下吃了个中餐。晚上参加到了Hyatt Place酒店后，我在房间睡了一觉。队友们有的去了PPP组织的party。9点多的时候被Oroggs叫醒，自己打车去长街溜达了一圈，看了看沿路的一些酒店，12点半回到酒店睡觉。
8月12日 南奥特莱斯一日游，有钱人在蔻驰的购买力真的牛逼。晚上吃了帝王蟹腿和虾。送走了当天凌晨返回北京的队友之后自己打车入住了Bally&amp;rsquo;s酒店。11点入住完早上4点就撤，血亏。
DEFCON总结  一个web手在DEFCON中还是能够很好的生存的，因为其实就是没我们什么事。把后勤处理好到处帮忙就好了。 本次比赛看上去还是存在部分沟通问题。在ropship这道题目中，由于沟通不到位，虽然攻击的策论貌似有人写了，但是由于基础代码没有写出来，所以也没什么鸟用。这件事情如果能进行有效的沟通，我们这个KoH没准可以得到一些分数。在以后的比赛中可以以此为鉴，合理优化题目分工。 我们队在AWD比赛中的基础设施一向是匮乏的，比如没有成熟的auto exploit framwork，没有成熟的比赛情况统计系统，所有设施都可能需要到现场手搓。对于DEFCON这种对手成熟甚至有职业队的比赛，可能导致我们在比赛中浪费较多的时间在基础建设。祝愿明年打defcon的时候能够有一套自己的可用的基础设施。  Whongton D.C. 8月13日 13号凌晨4点从酒店出发，乘坐飞往DC的飞机。由于飞机上有小孩子和装小孩子的车难以安置，所以起飞延误了一些。中午到达杜勒斯机场，乘坐2点左右的机场巴士($7.5)顺利到达一雄住处。在经历了早起、飞机上没午饭、空调温度巨低后又见巨大上下坡一度心态崩掉@_@。
在一雄家里喝了杯橙汁以后出发去乔治城先吃了个龙虾卷。吃完以后逛了乔治城和乔治城大学。乔治城里面都是一幢一幢的房子，街区非常漂亮，有些神似天津五大道，但是比五大道还要美。这里的变成了我心中最想住的地方。乔治城大学则是一个环境极好的大学，听一雄说里面贵胄子弟很多。学校里面的教学楼有种几百年前建筑的风格，让我实名嫌弃北大。
逛完以后二人来到河边长椅上瘫着，目力可及处能看到宽宽的河，大片的绿地，右手边的乔治城以及远方正在堵车的大桥。休息了一会儿后我们去了一家中餐厅吃火锅。据一雄说这家火锅店的中餐外卖养活了他一年。总体来说肉很瓷实，吃的很痛快。这顿饭开始，我逐渐开始接受美国的冰水（在此之前我都是接酒店的自来水喝）。由于这天的下午没有睡觉，导致晚上回去的时候又累又困，竟然像当年春晖一样举着直播直接睡着了。之后被一雄唤醒，关了视频睡下了。
8月14日 春晖和VV早上4点多抵达DC，check out以后去补觉了。我和一雄大概8点多起床，此时我的生物钟被彻底调整到纽约时区。10点左右，四人在白宫附近汇合。我们一起走了纪念碑，林肯纪念堂和Jefferson纪念堂。当天上午的阳光很厉害，中午大家都有些筋疲力竭。游览完以后，我们打车到了一雄提前订好的西餐厅。前菜是贝壳和柠檬鸡翅。光是前菜的量就已经很大了。主菜三个男生点了牛排，VV点了沙拉。牛排是5分熟的，非常好吃。配菜我点了西瓜和玉米。西瓜上面加了薄荷，很爽口。玉米我以为是玉米粒，但上上来以后发现是一整根玉米，最后硬着头皮吃完了，很甜但是也很撑233。
下午我们先被司机带到了美术馆A，但一雄发现这不是他之前去的那个美术馆B。于是在A里面转了半个多小时以后就出来然后走到了美术馆B。美术馆B有四层，每层都是长方形的环廊平分为四个风格不同的展区。期中芭比娃娃的画展，人体行为艺术和最上层的两个玻璃橱窗给我留下了较为深刻的印象。美术馆中间是个封闭式的天井，有好多巨大的空调吹着，呆在里面十分舒适。我们在里面喝了一杯饮料，感受了一下资本主义的奢靡。
在两个美术馆里，每一个展厅都有沙发或者长凳供参观者休息或者坐下来慢慢观赏，此处艾特国博等一票博物馆出来挨打。
晚上我们步行到附近的一家日料。在众人惊诧的目光中我第一次吃到了章鱼小丸子和鳗鱼饭。此时我已经完全接受冰水这种设定，不知道能不能在回国以后保持一波。吃完饭以后我们各回各家，我和一雄在房间里看快乐源泉张大仙。洗漱睡觉不表。
8月15日 早上起床，快10点的时候和春晖VV在某河的某码头汇合。我们先去吃了一个brunch。我点的是希腊风格的toast，吃过以后表示味道可以接受。吃完以后我带着我没喝完的奶昔上了皮划艇划船。春晖一个人划得比我和一雄两个人都快让我们感觉非常神奇。依稀记得上次划船应该还是小时候和父母在北海公园划，如今在异国划船，也算是重拾童趣。这天是阴天，没有很大的太阳，划船刚刚好。
由于春晖VV订了下午2点的bus去纽约，我们中午在旁边的Shink Shake吃了一顿。春晖VV吃了汉堡，我和一雄各点了一杯奶昔。奶昔巨天，第一口喝得超爽，但喝到一半以后就有点受罪了。
吃完饭后我们在旁边路上打车散伙。我们的uber司机纷纷走错路上错高速。其中我和一雄连续碰到了三次走错路然后取消的司机才顺利上车。打到的车的司机是一个埃及人，会用中文说“你好”和“谢谢”。我和一雄打车到家附近吃了越南粉，比较便宜但是也很好吃。
吃完饭以后回到一雄的公寓休息一会儿就收拾东西回Las Vegas了。由于雷雨天气，飞机延误两个小时。晚上10点左右到了McCarran机场，我上次来的时候行李在T1，于是就轻车熟路地走到了T1，然后发现并没有我的航班的belt。在四处询问以后发现我的行李带在T3，于是赶紧搭摆渡车冲回T3。
打车到Luxor金字塔酒店，司机蜜汁开到了后门，然后在酒店里转了半天才找到前台。check in以后发现自己的房间在一层，虽然说是金字塔房间但是毛线都看不到ヽ(#`Д´)ﾉ。洗漱睡觉不表。</description>
    </item>
    
    <item>
      <title>Redis &lt;= 5.0.5 RCE</title>
      <link>https://n0b0dycn.me/2019/07/redis-rce/</link>
      <pubDate>Sun, 07 Jul 2019 10:08:33 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/07/redis-rce/</guid>
      <description>Redis &amp;lt;= 5.0.5 RCE 本文介绍由LCBC战队队员Pavel Toporkov在zeronights 2018上介绍的redis 4.x RCE攻击。会议slide链接：https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf
攻击场景： * 能够访问远程redis的端口（直接访问或者SSRF） * 对redis服务器可以访问到的另一台服务器有控制权
本文的exp开源在github上：
https://github.com/n0b0dyCN/redis-rogue-server
欢迎大家来star~
背景知识 redis协议 redis支持两种传输协议，一种是明文传输，其命令如下：
SET keyname value\n  另一种是经过编码的传输协议：
*3\r\n$3\r\nSET\r\n$7\r\nkeyname\r\n$5\r\nval ue\r\n  将其格式化大概长这个样子：
*&amp;lt;number of arguments&amp;gt; CR LF $&amp;lt;number of bytes of argument 1&amp;gt; CR LF &amp;lt;argument data&amp;gt; CR LF ... $&amp;lt;number of bytes of argument N&amp;gt; CR LF &amp;lt;argument data&amp;gt; CR LF  笔者主要使用第二种协议实现exp。
CONFIG SET CONFIG SET命令用于对redis进行配置。常用如下：
CONFIG SET dir /VAR/WWW/HTML CONFIG SET dbfilename sh.</description>
    </item>
    
    <item>
      <title>Alpha 21264</title>
      <link>https://n0b0dycn.me/2019/04/alpha-21264/</link>
      <pubDate>Thu, 11 Apr 2019 17:04:22 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/04/alpha-21264/</guid>
      <description>前言 本文为北京大学研究生课程高等计算机体系结构（18-19学年第2学期）的作业。任务是对Alpha Microprocessor的设计进行综述。笔者才疏学浅，不到之处望读者斧正。
总览 Alpha 21264处理器每个周期可以取四条指令，同时其在内部支持乱序执行。在这种情况下，指令可以被并行执行，并且可以在其最早的能执行的时刻被执行。同时，此处理器支持推测执行，很大程度上加速了处理器的执行速度。Alpha 21264处理器复杂的转移预测机制支持了推测执行。在这些设计的支持下，该处理器的速度比前代Alpha 21164快50%到200%。
在存储系统方面，Alpha 21264提供了片上与片下的缓存系统，降低了访问存储的平均延迟。同时，21264也增加了对内存的并行访问，提高了数据带宽。在Stream benchmark中，Alpha 21264能够获得1.3GBytes/sec的访存速度。
Alpha 21264的主频在500至600MHz之间，由15M个2.2V，0.35mm晶体管组成。芯片面积为$3.1cm^2$，有587个管脚。芯片平面图如下：
芯片的结构抽象图如下：
指令流 (Instruction Pipeline &amp;ndash; Fetch) Alpha 21264处理器每个周期会向乱序执行部件传递四条指令。处理器会根据转移预测指令来进行指令的预取。由于转移预测的准确率极高，所以流水线在绝大部分时候都能被正确的指令所填充。
Alpha 21264通过两个结构支持取指的高效：路组预测(line and way prediction)和转移预测(branch prediction)。
Line and way prediction Alpha 21264处理器的I-Cache是64Kb，2路组相连。处理器实现了路预测算法，结合了组相联的缓存效率与直接映射缓存的访问速度。取指部件的结构图如下：
每次取四条指令之后，都会生成一个line和way的预测。该预测指向接下来四条指令的取指位置，包括line和way两个位置信息。处理器在根据预测读取接下来四条指令的同时，会并行地对正在执行的的四条指令的正确性进行检查。
在I-Cache被填充时，以及预测出错时，预测器会被重新训练。在绝大部分的应用程序中，预测器对于line的预测正确率达到了85%，对way的预测准确率达到了100%。为了避免过度训练，预测器设置了2 bit的滞后计数器。当且仅当目前预测器多次发生错误的时候才会进行重新训练。由于预测的高准确率以及很低的miss panalty，该预测机制能够大大提升处理器速度。不仅如此，对于一些可预测的跳转（如动态链接库的调用），可以被很好地训练，减少了计算转移地址的开销（约8个周期）。
当I-Cache发生缓存不命中时，I-Cache会向L2缓存预取最多64字节的数据（即16条指令）。这种预取模式很大地提高了取指的带宽。
转移预测 相比于前代的处理器，转移预测模块对于Alpha 21264的影响更大，原因如下：
 Alpha 21264的panelty是7个周期，比前代稍高。 Alpha 21264处理器的指令执行速度大大提升。 成功的转移预测能够更好地配合推测执行机制。21164处理器可以容纳20条推测执行的指令，而21264可以容纳多达80条指令。  Alpha 21264的转移预测系统从局部预测和全局预测中动态选择。再绝大多数benchmark中可以得到90%到100%的准确率。21264的预测器结构如下图：
该图左侧是10-bit局部转移pattern，并包含3-bit计数器。局部预测器根据这10-bit从1024个转移计数器中选取一个。图右侧是12-bit的全局转移预测器，对应着全局信息表中的4096个条目之一。同时处理器还有一个Choice Predictor来决定选择哪个预测器的结果。这个predictor根据12-bit的全局记录对4096个条目进行索引。
当一个转移指令被最终提交之后，局部预测器被更新。当一个转移指令发射时，全局计数器就会提前被更新。当然，全局计数器会保存该计数器的备份来防止转移预测失败。
乱序执行 (Out-Of-Order Execution) Alpha 21264的乱序执行机制允许每个周期发射四条指令。OOO部件会对寄存器进行重命名及映射以解决不必要的寄存器依赖。指令将会被放在队列中，等待其需要的部件的空闲。Alpha 21264有两个定点运算部件以及两个浮点运算部件，所以每个周期处理器最多同时指令6条指令。
下图是乱序执行部件的结构图：
寄存器重命名 寄存器重命名为每条指令分配程序员不可见的结果寄存器。这种技术有以下优点：
 较好地支持推测执行 在解决了write-after-read和write-after-write冲突的同时保留了read-after-write的依赖  上图的左侧更详细地展示了重命名部件。不难发现，寄存器重命名是在Content-Addressable Memory(CAM)上完成的。流水线中所涉及到的所有操作都发生在重命名后的寄存器中，而不是用户可见的寄存器。</description>
    </item>
    
    <item>
      <title>0ctf 2019 Quals Web writeup</title>
      <link>https://n0b0dycn.me/2019/03/0ctf-2019-quals-web-writeup/</link>
      <pubDate>Tue, 26 Mar 2019 16:04:55 +0800</pubDate>
      
      <guid>https://n0b0dycn.me/2019/03/0ctf-2019-quals-web-writeup/</guid>
      <description>本次比赛两个web题都是RicterZ大佬出的，膜一波Orz
Ghost Pepper 本题首先通过观察401的响应包找到HTTP Basic认证的用户名karaf：
然后用密码karaf即可绕过认证。接下来通过目录爆破找到目录http://karaf:karaf@192.168.2.88:31337/jolokia/。到这里我们可以发现这是一个裸的jolokia控制台。
jolokia是一个Java系统管理解决方案。其采用轻量级的Json格式传输数据，可以方便地管理系统中的Servlet。所以当应用暴露了jolokia目录的时候，基本上算是直接暴露出来一个webshell。我们可以通过访问http://karaf:karaf@192.168.2.88:31337/jolokia/list来查看可用的api，来寻找利用点。在本题中有三种解题方式：
解法 1 通过karaf下bundle模块远程安装一个我们自己写的恶意bundle，反弹一个shell到自己的服务器上。参考https://github.com/p4-team/ctf/tree/master/2019-03-23-0ctf-quals/web_osgi。但是由于我不熟悉Java编译出来的东西始终装不上Orz，等弄好了把整个项目代码扔github上面去= =
解法 2 第二种方法应该算是最省事的方法了，即通过karaf下feature模块安装一个webconsole：
之后我们访问http://192.168.2.88:31337/system/console/bundles就可以进入到webconsole的管理界面。在管理界面点Main -&amp;gt; Goto即可进入console。
在console中执行cat /flag即可得到flag：
解法 3 使用karaf中的Instance模块，在安装一个新的instance的时候进行instance的命令行参数注入。我们看karaf源码：https://github.com/apache/karaf。在org/apache/karaf/instance/core/InstancesMBean.java文件中定义了MBean的接口：
// Operations void startInstance(String name) throws MBeanException; void startInstance(String name, String opts) throws MBeanException; void startInstance(String name, String opts, boolean wait, boolean debug) throws MBeanException;  我们找startInstance方法的实现，在文件org/apache/karaf/instance/command/StartCommand.java中其调用了Instance的Start方法：
跟进Instance类的start方法，其调用了InstanceService中的startInstance方法：
继续跟进org/apache/karaf/instance/core/internal/InstanceServiceImpl.java，其调用了doStart方法：
继续看doStart方法，其中有明显的命令拼接：
在此处，我们发现javaOpt是我们可控的参数。在InstancesMBeanImpl中我们发现createInstance参数有一个就是javaOpt：
于是我们给出攻击思路：
 创建一个新的Instance，在其javaOpt字段进行参数注入 开启这个新的Instance执行我们的命令 停止Instance 删除Instance  最后我们给出exp：
import requests from pprint import pprint url = &amp;quot;http://111.</description>
    </item>
    
  </channel>
</rss>